#数据精度

| 类型   | 字节数  | 符号位 | 指数位 | 尾数位 |
| ------ | ------- | ------ | ------ | ------ |
| byte   | 1(8bit) | 1      | \      | \      |
| short  | 2       | 1      | \      | \      |
| int    | 4       | 1      | \      | \      |
| long   | 8       | 1      | \      | \      |
| float  | 4       | 1      | 8      | 23     |
| double | 8       | 1      | 11     | 52     |

数值 = 尾数 * 底数 ^ 指数

如： 120.5 = 1.205 * 10 ^ 2

所以范围由**指数位** 决定，精度由尾数决定。

***float***：最多小数点后7位，可以保证小数点后6位。

***double***：最多小数点后16位，可以保证小数点后15位。

------

#数据转换

## 1. 小类型向类型转换

一般情况安全，但小类型精度高于大类型时要注意精度丢失的问题。

如： int => float

* 虽然都是4个字节，但是float的8个比特位都是指数位，即2^(-127～128)。所以比int的2^31大。
* int => float时，会采用科学计数法，而float精度只有23位，所以如果24位以后的精度会丢失。

##2. 大类型向小类型转换（强制类型转换）

```java
byte b = 5;
b = (byte)(b+10);
//默认使用int处理
//和转换无关
```

```java
int i = 129;
byte b = (byte)i;
//129 = 10000001
//取反加一
//01111111：即 b = -127
```

```java
int i = 257;
byte b = (byte)i;
//257 = 1,0000,0001
//byte只能存储8位
//舍弃第一位
//,0000,0001：即 b = 1
```

------

# 数组：

## 初始化：

### 动态初始化

```java
int score[] = new int[3];
```

### 静态初始化

```java
int score[] = {2, 4, 6, 7};
```

------

# String

* 字符串内容不可更改

  如：

  ```java
  String str = "hello";
  String str = str + "world";
  ```

  其中“hello”，并没有被更改，而是开辟新的内存空间，仍然存在堆空间中，堆空间含有：`hello`,`world`,`helloworld`，并把str的地址指向`helloworld`。

------

# StringBuffer

* 由于string不可改变，每次都要新开辟内存空间，浪费内存资源。而StringBuffer可以改变。不浪费内存空间。

----

# StringBuilder

* 单线程使用的时候，速度比StringBuffer快，建议使用StringBuilder。
* 若涉及到线程安全问题时，建议使用StringBuffer。